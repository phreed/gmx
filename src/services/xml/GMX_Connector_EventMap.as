/*
 *      Copyright (c) Vanderbilt University, 2006-2009
 *      ALL RIGHTS RESERVED, UNLESS OTHERWISE STATED
 *
 *      Developed under contract for Future Combat Systems (FCS)
 *      by the Institute for Software Integrated Systems, Vanderbilt Univ.
 *
 *      Export Controlled:  Not Releasable to a Foreign Person or
 *      Representative of a Foreign Interest
 *
 *      GOVERNMENT PURPOSE RIGHTS:
 *      The Government is granted Government Purpose Rights to this
 *      Data or Software.  Use, duplication, or disclosure is subject
 *      to the restrictions as stated in Agreement DAAE07-03-9-F001
 *      between The Boeing Company and the Government.
 *
 *      Vanderbilt University disclaims all warranties with regard to this
 *      software, including all implied warranties of merchantability
 *      and fitness.  In no event shall Vanderbilt University be liable for
 *      any special, indirect or consequential damages or any damages
 *      whatsoever resulting from loss of use, data or profits, whether
 *      in an action of contract, negligence or other tortious action,
 *      arising out of or in connection with the use or performance of
 *      this software.
 *
 *
 *
 */

// -*-as-*-
// GMX_Connector_EventMap.as: Auto generated
// $Rev$: $Date$

package services.xml   // hard coded
{

	import gmx_builder.GMXBuilder;
	import services.IEventMap	
	
	import GMX.Data.RecordVO;
	
	import GMX.Data.CollectionVO;
	
	import GMX.Data.AttributeVO;
	


	public class GMX_Connector_EventMap implements IEventMap
	{
		public function GMX_Connector_EventMap()
		{
		}
		
		public function init():void
		{
		}

		public function getStronglyTypedArgs(fnName:String, args:Array):Array
		{
			// Find the right handler()				

			if (0)
				;
			
			else if (fnName == "ISISLayout") 
			{
				return ISISLayout_Reader(args);
			}
			
			else if (fnName == "ISISRecord") 
			{
				return ISISRecord_Reader(args);
			}
			
			else if (fnName == "ISISCollection") 
			{
				return ISISCollection_Reader(args);
			}
			
			else if (fnName == "ISISAttributes") 
			{
				return ISISAttributes_Reader(args);
			}
			
			else
				trace("Sent Message fnName="+ fnName +"  was NOT RECOGNIZED!");
				
			return new Array(); //empty args
		}

		public function getXMLArgs(fnName:String, args:Array):XML
		{
			// Find the right handler()				

			if (0)
				;
			
			else if (fnName == "ISISRefresh") 
			{
				return ISISRefresh_Writer(args);
			}
			
			else if (fnName == "ISISDataEdit") 
			{
				return ISISDataEdit_Writer(args);
			}
			
			else
				trace("Sent Message NOT RECOGNIZED!");
			
			return new XML();
		}


		/******************************  Handlers for Messages From Service  ******************************/
		
		private function ISISLayout_Reader(args:Array):Array
		{
			var typedArgs:Array = new Array();
			var i:int = 0;
			
			      // Primitive  
			
			var a_Layout:String;
			/*  
			// originally thought we have to do somthing kind of silly because the toString method for XML ignores the top
			// level node if it does not have any XML nodes for children... but this is only an issue if the layout manager
			// does not use the <Layout> tag before sending the layout string (in CDATA format).  The autogenerated code
			// does add this <Layout> tag, but technically layouts can be sent without it and then without using the CDATA
			// escaping... however, this was a problem if the XML has no child nodes... but ANYWAY, since the auto generated
			// code adds the <Layout> tag, we're just going to assume that's how all the layout messages will come and
			// not worry about using the toXMLString() function instead of the toString() function.
			var xml:XML = args[i] as XML;
			if (xml == null) {
				a_Layout = String(args[i]); 
			} else {
				a_Layout = xml.toXMLString(); // includes start tag if it has no children
			}*/
			a_Layout = String(args[i]); 
			typedArgs.push(a_Layout);
			
			i++;
			
	
			return typedArgs;
	
		}
		
		private function ISISRecord_Reader(args:Array):Array
		{
			var typedArgs:Array = new Array();
			var i:int = 0;
			
			            
			// Array of Composite
			var a_RecordList:Array = new Array;
			for each (var RecordNode:XML in args[i].Record)
			{ 
				var a_Record:RecordVO = new RecordVO;
				a_Record.fromXML(RecordNode);
				a_RecordList.push(a_Record);
			}
			typedArgs.push(a_RecordList);
			
			
			i++;
			
	
			return typedArgs;
	
		}
		
		private function ISISCollection_Reader(args:Array):Array
		{
			var typedArgs:Array = new Array();
			var i:int = 0;
			
			            
			// Array of Composite
			var a_CollectionList:Array = new Array;
			for each (var CollectionNode:XML in args[i].Collection)
			{ 
				var a_Collection:CollectionVO = new CollectionVO;
				a_Collection.fromXML(CollectionNode);
				a_CollectionList.push(a_Collection);
			}
			typedArgs.push(a_CollectionList);
			
			
			i++;
			
	
			return typedArgs;
	
		}
		
		private function ISISAttributes_Reader(args:Array):Array
		{
			var typedArgs:Array = new Array();
			var i:int = 0;
			
			            
			// Array of Composite
			var a_AttributeList:Array = new Array;
			for each (var AttributeNode:XML in args[i].Attribute)
			{ 
				var a_Attribute:AttributeVO = new AttributeVO;
				a_Attribute.fromXML(AttributeNode);
				a_AttributeList.push(a_Attribute);
			}
			typedArgs.push(a_AttributeList);
			
			
			i++;
			
	
			return typedArgs;
	
		}
		

		/******************************  Handlers for Messages To Service  ******************************/
		
		public function ISISRefresh_Writer(args:Array):XML
		{
			var i:int = 0;
			var argsList:XML = <args></args>;
			
			      // Primitive  
			var CommandXml:XML = <arg><Command>{args[i]}</Command></arg>;	
			argsList.appendChild(CommandXml);
			
			i++;
			
			
			return argsList;
		}
		
		public function ISISDataEdit_Writer(args:Array):XML
		{
			var i:int = 0;
			var argsList:XML = <args></args>;
			
			            
			// Array of Composite
			var RecordListXml:XML = <arg><RecordList></RecordList></arg>;			
			for (var j:int = 0; j<args[i].length; j++)
			{
				var a_Record:XML = <Record/>;
				args[i][j].toXML(a_Record);
				RecordListXml.RecordList.appendChild(a_Record);
			}
			argsList.appendChild(RecordListXml);
			
			
			i++;
			
			
			return argsList;
		}
		
	}
}
